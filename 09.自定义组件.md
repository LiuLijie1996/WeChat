### 什么是自定义组件

+ 开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。

+ components组件文件夹中的每个组件
  1. 小程序的组件里面的构造函数是Component
  2. properties字段就是接受父组件或是父页面传来的数据的
  3. methods存储着组件的方法
  4. 组件的json文件里面一定有一个component字段,里面的值一定得是true



### 组件的文件结构

```
title (title组件的文件夹)
	title.js (组件的js)
	title.json (组件的json文件)
	title.wxml (组件的标签架构)
	title.wxss (组件的样式)
```



### 组件的引用方式

```json
//在父组件的json文件中引入子组件
{
  "usingComponents": {
    //取一个见名知意的名字，值为组件的绝对路径
    "component-title": "/components/title/title"
  }
}
```

```html
<!--在父组件的wxml中引入名字即可-->
<component-title></component-title>
```



### 自定义组件之插槽

+ 默认情况下，一个组件的wxml中只能有一个slot。需要使用多slot时，可以在组件js中声明启用. 原理和Vue里面的具名插槽差不多

```html
<!-- 自定义组件的wxml文件 -->
<view>
    <text>这是title组件，用于页面的标题部分</text>

    <!--匿名插槽,如何数据都可以插进来-->
    <slot></slot>

    <!--具名插槽,只有名字匹配上了才能把数据插进来-->
    <slot name="img"></slot>

    <!--
        插槽:
            组件大部分都是复用的
            但是允许在某些小区域内,插入一些自定义的内容
            使用起来和vue还是挺像的,但是需要在options中进行配置
    -->
</view>
```

```js
// 自定义组件的js文件
Component({
    /**
     * 组件的配置
     */
    options: {
        multipleSlots: true,//允许该组件使用多个插槽
    },
})
```

+ 父组件或页面的wxml文件

  ```html
  <view>
      <component-title class="one">
          <view>我是匿名插槽中的内容</view>
          
          <!-- 使用时，用 slot 属性来将节点插入到不同的slot上。 -->
          <image slot="img" src="/static/image/02.jpg"/>
      </component-title>
  </view>
  ```

  

### 自定义组件之样式隔离

+ 默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：

  1. app.wxss 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
  2. 指定特殊的样式隔离选项 styleIsolation 。

  

+ styleIsolation 选项从基础库版本 2.6.5 开始支持。它支持以下取值：

  1. isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；
  2. apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；
  3. shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件。（这个选项在插件中不可用。）

```js
// 自定义组件的js文件
Component({
    /**
     * 组件的配置
     */
    options: {
        multipleSlots: true,//允许该组件使用多个插槽
        
        /*
        * styleIsolation
        *   isolated  样式隔离(默认)
        *   apply-shared  父组件可以直接影响子组件,但反过来就不行
        *   shared  组件的样式也会影响页面的样式
        *	page-shared	 页面样式共享
        * */
        styleIsolation: "isolated",
    }
})
```



### 自定义组件之外部样式类

```js
// components/title/title.js
Component({
    /**
     * 拓展类
     *  在样式隔离的情况下,使用拓展类,就可以使用在父组件定义的样式了
     *  数组中的每项值是父组件中引入组件时,在组件上添加的类名
     */
    externalClasses: ['one', /*className...*/],
})
```

+ 父级组件wxml代码

  ```html
  <!-- 给引入进来的子组件定义一个类名 -->
  <component-title class="one">
      <!--匿名插槽是不需要slot来指定的-->
      <view>我是匿名插槽中的内容</view>
  
      <!--具名插槽是需要用slot来指定的-->
      <image src="/static/image/02.jpg" slot="img"/>
  </component-title>
  ```

+ 父级组件wxss代码

  ```css
  /* 这里的样式可以影响到子组件的样式 */
  .one{
      color:red;
      font-size:30px;
  }
  ```

  

### 自定义组件之调用父组件的样式

+ 自定义组件的wxml文件

```html
<view class="^abc">
    <text>我是子组件,在这里我直接调用了父组件的样式</text>
</view>

或

<view class="~abc">
    <text>我是子组件,在这里我直接调用了父组件的样式</text>
</view>
```



### 组件的生命周期

+ 组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

+ 其中，最重要的生命周期是 created, attached, detached ，包含一个组件实例生命流程的最主要时间点。

  1. 组件实例刚刚被创建好时， created 生命周期被触发。此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data 。 此时还不能调用 setData 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。
  2. 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
  3. 在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。

  | **生命周期** | **参数**     | **描述**                                 |
  | ------------ | ------------ | ---------------------------------------- |
  | created      | 无           | 在组件实例刚刚被创建时执行               |
  | attached     | 无           | 在组件实例进入页面节点树时执行           |
  | ready        | 无           | 在组件在视图层布局完成后执行             |
  | moved        | 无           | 在组件实例被移动到节点树另一个位置时执行 |
  | detached     | 无           | 在组件实例被从页面节点树移除时执行       |
  | error        | Object Error | 每当组件方法抛出错误时执行               |



+ 还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。其中可用的生命周期包括：

  | **生命周期** | **参数**    | **描述**                     |
  | ------------ | ----------- | ---------------------------- |
  | show         | 无          | 组件所在的页面被展示时执行   |
  | hide         | 无          | 组件所在的页面被隐藏时执行   |
  | resize       | Object Size | 组件所在的页面尺寸变化时执行 |

```js
Component({
    /*
    * 监听组件所在页面的生命周期
    * */
    pageLifetimes: {
        /*
        * 页面显示时触发
        * */
        show() {
        },

        /*
        * 页面隐藏时触发
        * */
        hide() {
        },

        /*
        * 页面大小变化时触发
        * */
        resize(size) {
        }
    },

    /*
    * 组件自身的生命周期
    * */
    lifetimes:{
        /*
        * 组件初始化时触发
        *   这个阶段可以获取数据,但不能设置数据
        * */
        created() {
        },

        /*
        * 组件被挂载到页面时触发
        * */
        attached() {
        },

        /*
        * 组件卸载时触发
        *  */
        detached() {
        },

        /*
        * 组件在视图层布局完成时触发
        * */
        ready() {
        },

        /*
        * 组件抛出错误时触发
        * */
        error(err) {
        }
    }
});
```



### 自定义组件的基本注意点

1. 注意：组件的名字里面可以包含大写小,连字符等. 但是大写的字母会被自动转成小写的, 连字符会被保留下来
2. WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
3. 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 usingComponents 字段）。
4. 自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。
5. 在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。就用class选择器, 这是因为小程序的样式是一个阉割版的, 没有原生的css那般强大



### 组件的样式注意点

+ 组件对应 wxss 文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意以下几点：
  1. 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择。器，请改用class选择器。
  2. 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。
  3. 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。
  4. 继承样式，如 font 、 color ，会从组件外继承到组件内。
  5. 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。